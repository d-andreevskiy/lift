/*

> Виталий Мореходов:
Входы 
1- A0  = автомат вниз
2 - А1 = автомат вверх
3 - A2 = Ручной режим вниз
4 - А3 = Ручной режим вверх
5 - А4 = Концевой
6 - А5 = Датчик нагрузки (Токовый датчик)
7 - А6 = Экран вниз
8 - А7 = Экран вверх  
9 - D2 = Работает только экран 
10 - D3 = Работает только лифт
11 - D4 = Резерв
12 - D5 = Резерв

Выходы
D - 6 = Реле питания. (Бок питания 24 вольта + розетка проектора)
D - 7 = Экран вниз
D - 8 = Экран вверх
D - 9 = Экран стоп
D - 10 = Драйвер "Enable"
D - 11 =Драйвер "CW"
D - 12 =Драйвер "CLK"
D - 13 = Резерв


1- A0  = автомат вниз 
При коротком и длинном нажатии 
Проверяет состояния входов "9 - D2 = Работает только экран  и 10 - D3 = Работает только лифт"
Ели они не задействованы, то :
на выход D7  подается короткий сигнал, для опускания экрана, 
так же включается реле питания D6 и через 1 секунду ,проектор начинает ехать вниз в автомате

По истечении времени заданного переменной, (Время опускания экрана)  на выход D9 (Экран стоп). 
Подается короткий импульс. Далее, если не поступало сигнала "Автомат вверх", то при повторном нажатии вниз выходы управления экраном не активны 
( что бы экран не опускался ниже заданной временем точки. )

Если задействован один из входов   "9 - D2 = Работает только экран  и 10 - D3 = Работает только лифт" 
Соответственно работает только алгоритм с экраном или же с проектором
По истечении 10 ти минут если не пришел сигнал от датчика тока ( 6 - А5 = Датчик нагрузки (Токовый датчик)),  Реле питания D - 6  выключается.
Повторное включение реле производится нажатием на кнопку автомат вниз или вверх.

Все циклы должны завершаться полностью. , после завершения цикла опускания, можно начать цикл поднятия,  и наоборот
Понятно что то?
2 - А1 = автомат вверх Так же как и Автомат вниз
Но в выходы вверх соответственно . Возможно - скорее всего 100% использовать сигнал стоп для экрана ненужно , 
так как он в верхней точке остановится по датчику тока, в своем контролере. 
Но необходимо задать время выполнения цикла подъема экрана, равное переменной (Время опускания экрана) + 5 секунд. 
Что бы повторный цикл опускания, не начал опускать экран с не полностью убранного положения.
3 - A2 = Ручной режим вниз
4 - А3 = Ручной режим вверх
Проверяет состояние входа "9 - D2 = Работает только экран " и если он задействован, 
то перенаправляет сигналы на выходы управления экраном "D - 7, D - 8" Если не задействован, то управляет проектором.
Описание работы ты знаешь, пока держишь крутит
При нажатии на любую из кнопок, включается D6 и через 1 секунду ,проектор начинает ехать вниз или вверх

Следит за датчиком тока, если от него приходит сигнал, реле не выключается, если не приходит, выключается через 10 минут.
После каждого нажатия на кнопку вниз или вверх. Счетчик реле обнуляется.
Если реле включено секунду можно не ждать (Она нужна для запуска БП)
5 - А4 = Концевой - Ты знаешь
6 - А5 = Датчик нагрузки (Токовый датчик) Поистечени 10 минут после снятия сигнала и если нет других нажатий на кнопки управления
лифтом , снимает управление с реле питания D - 6
Если есть сигнал, реле всегда включено
7 - А6 = Экран вниз
8 - А7 = Экран вверх 
Сквозной вход  в выходы 
D - 7 = Экран вниз
D - 8 = Экран вверх
Пока сигнал есть на входе, он есть и на выходе. Работают всегда
Завтра почитаю
9 - D2 = Работает только экран 
10 - D3 = Работает только лифт
Это входы задающие какие устройства работают в автоматическом и ручном режиме.
Если выбран только экран, то в ручном режиме сигналы передаются на экран . Как и выше  на выходы (D - 7 = Экран вниз
D - 8 = Экран вверх)
Во всех остальных вариантах В ручном режиме работает только проектор.
*/


#define EN 10
#define CW 11
#define CLK 12
#define POW 6


#define GS_FAST_PROFILE 10
#include "stepper.h"

#define GS_NO_ACCEL 1
//GStepper2<STEPPER4WIRE> stepper(2048, 5, 3, 4, 2);
GStepper2 stepper(2048, CLK, CW);

uint32_t tar = -20000;
bool dir =1;


enum lift_states { 
              STOP_DOWN,
              STOP_UP, 
              LIFT_DOWN, 
              LIFT_UP,
              LIFT_STEP_DOWN,
              LIFT_STEP_UP,
              MAX_STATES } current_state;

void lift_step_down (void);
void lift_step_up (void);
void lift_down (void) ;
void lift_up (void);
void lift_stop (void);

void none(void){};


enum lift_events { 
              EV_LIFT_DOWN, 
              EV_LIFT_ST_DOWN,
              EV_LIFT_UP,
              EV_LIFT_ST_UP,
              EV_LIMIT_SW,
              EV_STEP_OVER,
              MAX_EVENTS,
              } new_event;



enum lift_events get_new_event (void);


void (*const state_table [MAX_STATES][MAX_EVENTS]) (void) = {
//             EV_LIFT_DOWN, EV_LIFT_ST_DOWN, EV_LIFT_UP, EV_LIFT_ST_UP, EV_LIMIT_SW, EV_STEP_OVER,
/*STOP_DOWN*/{ none,         none,            lift_up,    lift_step_up,  none,        none  },
/*STOP_UP*/  { lift_down,    lift_step_down,  none,       none,          none,        none  },
/*DOWN*/     { none,         none,            none,       none,          none,        lift_stop },
/*ST_DOWN*/  { none,         none,            none,       none,          none,        lift_stop },
/*UP*/       { none,         none,            none,       none,          lift_stop,   none },
/*ST_UP*/    { none,         none,            none,       none,          lift_stop,   none },
    
};



void lift_step_down (void){};
void lift_step_up (void){};
void lift_down (void){} ;
void lift_up (void){};
void lift_stop (void){};

enum lift_events get_new_event (void)
{
    return EV_LIFT_DOWN;
}


void setup() {
  pinMode(POW, OUTPUT);
  digitalWrite(POW, HIGH);

  stepper.enable();
  stepper.setMaxSpeed(3000);     // скорость движения к цели
  stepper.setAcceleration(10000); // ускорение
  stepper.setTarget(tar);       // цель
}


void loop() {
  // put your main code here, to run repeatedly:

  while (1) {
    new_event = get_new_event (); /* get the next event to process */
    
    stepper.tick();

    // если приехали
    if (stepper.ready()) {
      dir = !dir;
      stepper.setTarget(dir * tar);
      stepper.power(false);
      delay(10000);
      stepper.power(true);

    }


    if (((new_event >= 0) && (new_event < MAX_EVENTS))
    && ((current_state >= 0) && (current_state < MAX_STATES))) {

        state_table [current_state][new_event] (); /* call the action procedure */

    }
  }
}

